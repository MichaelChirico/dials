#' Find recommended methods for generating parameter values
#'
#' `tunable()` determines which parameters in an object _can_ be tuned along
#' with information about the parameters.
#' @param x An object, such as a recipe, recipe step, or `parsnip` model
#' specification.
#' @param ... Not currently used.
#' @return A tibble with a column for the parameter `name`, information on the
#' _default_ method for generating a corresponding parameter object, the
#' `source` of the parameter (e.g. "recipe", etc.), and the `component` within
#' the source. For the `component` column, examples would be the step type
#' (e.g. "step_normalize") or whether the model specification argument was a
#' main parameter or one associated with the engine.
#' @details
#' For a model specification, an engine must be chosen.
#'
#' If the object has no tunable parameters, a tibble with no rows is returned.
#'
#' The information about the default parameter object takes the form of a
#' named list with an element for the function call and an optional element for
#' the source of the function (e.g. the `dials` package). For model
#' specifications, If the parameter is unknown to the underlying `tunable`
#' method, a `NULL` is returned.
#' @examples
#'
#' load(system.file(package = "dials", "objects", "tunable_examples.RData"),
#'      verbose = TRUE)
#'
#' tunable(bare_rec)
#'
#' tunable(umap_rec)
#'
#' # models:
#'
#' tunable(bst_model)
#'
#' tunable(lm_model)
#'
#' @export
tunable <- function(x, ...) {
  UseMethod("tunable")
}

#' @rdname tunable
#' @export
no_param <-
  tibble::tibble(
    name = NA_character_,
    call_info = list(),
    source = NA_character_,
    component = NA_character_,
    component_id = NA_character_
  )

#' @rdname tunable
#' @export
step_type <- function(.step) class(.step)[class(.step) != "step"][1]
mod_type <- function(.mod) class(.mod)[class(.mod) != "model_spec"][1]

#' @rdname tunable
#' @export
tunable.step <- function(x, ...) {
  no_param
}

#' @importFrom dplyr %>% mutate select filter full_join
#' @rdname tunable
#' @export
tunable.model_spec <- function(x, ...) {
  mod_env <- rlang::ns_env("parsnip")$parsnip

  if (is.null(x$engine)) {
    stop("Please declare an engine first using `set_engine()`.", call. = FALSE)
  }

  arg_name <- paste0(mod_type(x), "_args")
  if (!(any(arg_name == names(mod_env)))) {
    stop("The `parsnip` model database doesn't know about the arguments for ",
         "model `", mod_type(x), "`. Was it registered?",
         sep = "", call. = FALSE)
  }

  arg_vals <-
    mod_env[[arg_name]] %>%
    dplyr::filter(engine == x$engine) %>%
    dplyr::select(name = parsnip, call_info = func) %>%
    dplyr::full_join(
      tibble::tibble(name = c(names(x$args), names(x$eng_args))),
      by = "name"
    ) %>%
    # TODO inlcude submodels?
    dplyr::mutate(
      source = "model_spec",
      component = mod_type(x),
      component_id = ifelse(name %in% names(x$args), "main", "engine"))

  if (nrow(arg_vals) > 0) {
    has_info <- purrr::map_lgl(arg_vals$call_info, is.null)
    rm_list <- !(has_info & (arg_vals$component_id == "main"))

    arg_vals <- arg_vals[rm_list,]
  }
  arg_vals %>% dplyr::select(name, call_info, source, component, component_id)
}

# ------------------------------------------------------------------------------

#' @rdname tunable
#' @export
tunable.step_bagimpute <- function(x, ...) {
  tibble::tibble(
    name = "trees",
    call_info = list(list(pkg = "dials", fun = "trees")),
    source = "recipe",
    component = "step_bagimpute",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_bs <- function(x, ...) {
  tibble::tibble(
    name = c("deg_free", "degree"),
    call_info = list(
      list(pkg = "dials", fun = "deg_free"),
      list(pkg = "dials", fun = "degree")
    ),
    source = "recipe",
    component = "step_bs",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_corr <- function(x, ...) {
  tibble::tibble(
    name = "threshold",
    call_info = list(
      list(pkg = "dials", fun = "threshold")
    ),
    source = "recipe",
    component = "step_corr",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_discretizes <- function(x, ...) {
  tibble::tibble(
    name = c("min_unique", "num_breaks"),
    call_info = list(
      list(pkg = "dials", fun = "min_unique"),
      list(pkg = "dials", fun = "num_breaks")
    ),
    source = "recipe",
    component = "step_discretize",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_downsample <- function(x, ...) {
  tibble::tibble(
    name = "under_ratio",
    call_info = list(
      list(pkg = "dials", fun = "under_ratio")
    ),
    source = "recipe",
    component = "step_downsample",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_ica <- function(x, ...) {
  tibble::tibble(
    name = "num_comp",
    call_info = list(list(pkg = "dials", fun = "num_comp")),
    source = "recipe",
    component = "step_ica",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_isomap <- function(x, ...) {
  tibble::tibble(
    name = c("num_terms", "neighbors"),
    call_info = list(
      list(pkg = "dials", fun = "num_terms"),
      list(pkg = "dials", fun = "neighbors")
    ),
    source = "recipe",
    component = "step_isomap",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_knnimpute <- function(x, ...) {
  tibble::tibble(
    name = "neighbors",
    call_info = list(list(pkg = "dials", fun = "neighbors")),
    source = "recipe",
    component = "step_knnimpute",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_kpca_poly <- function(x, ...) {
  tibble::tibble(
    name = c("num_comp", "degree", "scale_factor", "offset"),
    call_info = list(
      list(pkg = "dials", fun = "num_comp"),
      list(pkg = "dials", fun = "degree"),
      list(pkg = "dials", fun = "scale_factor"),
      list(pkg = "dials", fun = "offset")
      ),
    source = "recipe",
    component = "step_kpca_poly",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_kpca_rbf <- function(x, ...) {
  tibble::tibble(
    name = c("num_comp", "sigma"),
    call_info = list(
      list(pkg = "dials", fun = "num_comp"),
      list(pkg = "dials", fun = "rbf_sigma")
    ),
    source = "recipe",
    component = "step_kpca_rbf",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_meanimpute <- function(x, ...) {
  tibble::tibble(
    name = "trim",
    call_info = list(
      list(pkg = "dials", fun = "trim_amount")
    ),
    source = "recipe",
    component = "step_meanimpute",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_nnmf <- function(x, ...) {
  tibble::tibble(
    name = c("num_comp", "num_run"),
    call_info = list(
      list(pkg = "dials", fun = "num_comp"),
      list(pkg = "dials", fun = "num_run")
    ),
    source = "recipe",
    component = "step_nnmf",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_ns <- function(x, ...) {
  tibble::tibble(
    name = c("deg_free"),
    call_info = list(
      list(pkg = "dials", fun = "deg_free")
    ),
    source = "recipe",
    component = "step_ns",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_nzv <- function(x, ...) {
  tibble::tibble(
    name = c("freq_cut", "unique_cut"),
    call_info = list(
      list(pkg = "dials", fun = "freq_cut"),
      list(pkg = "dials", fun = "unique_cut")
    ),
    source = "recipe",
    component = "step_nzv",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_other <- function(x, ...) {
  tibble::tibble(
    name = "threshold",
    call_info = list(
      list(pkg = "dials", fun = "threshold")
    ),
    source = "recipe",
    component = "step_other",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_pca <- function(x, ...) {
  tibble::tibble(
    name = "num_comp",
    call_info = list(list(pkg = "dials", fun = "num_comp")),
    source = "recipe",
    component = "step_pca",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_poly <- function(x, ...) {
  tibble::tibble(
    name = c("degree"),
    call_info = list(
      list(pkg = "dials", fun = "degree_num")
    ),
    source = "recipe",
    component = "step_poly",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_pls <- function(x, ...) {
  tibble::tibble(
    name = "num_comp",
    call_info = list(list(pkg = "dials", fun = "num_comp")),
    source = "recipe",
    component = "step_pls",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_rollimpute <- function(x, ...) {
  tibble::tibble(
    name = c("statistic", "window"),
    call_info = list(
      list(pkg = "dials", fun = "location_stat"),
      list(pkg = "dials", fun = "window")
    ),
    source = "recipe",
    component = "step_rollimpute",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_rollimpute <- function(x, ...) {
  tibble::tibble(
    name = c("statistic", "window"),
    call_info = list(
      list(pkg = "dials", fun = "location_stat"),
      list(pkg = "dials", fun = "window")
    ),
    source = "recipe",
    component = "step_rollimpute",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_upsample <- function(x, ...) {
  tibble::tibble(
    name = c("over_ratio"),
    call_info = list(
      list(pkg = "dials", fun = "over_ratio")
    ),
    source = "recipe",
    component = "step_upsample",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_window <- function(x, ...) {
  tibble::tibble(
    name = c("statistic", "window"),
    call_info = list(
      list(pkg = "dials", fun = "summary_stat"),
      list(pkg = "dials", fun = "window")
    ),
    source = "recipe",
    component = "step_window",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_embed <- function(x, ...) {
  tibble::tibble(
    name = c("num_terms", "hidden_units"),
    call_info = list(
      list(pkg = "dials", fun = "num_terms"),
      list(pkg = "dials", fun = "hidden_units")
    ),
    source = "recipe",
    component = "step_embed",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_umap <- function(x, ...) {
  tibble::tibble(
    name = c("neighbors", "num_comp", "min_dist", "learn_rate", "epochs"),
    call_info = list(
      list(pkg = "dials", fun = "neighbors"),
      list(pkg = "dials", fun = "num_comp"),
      list(pkg = "dials", fun = "min_dist"),
      list(pkg = "dials", fun = "learn_rate"),
      list(pkg = "dials", fun = "epochs")
    ),
    source = "recipe",
    component = "step_umap",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_woe <- function(x, ...) {
  tibble::tibble(
    name = c("Laplace"),
    call_info = list(
      list(pkg = "dials", fun = "Laplace")
    ),
    source = "recipe",
    component = "step_woe",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_texthash <- function(x, ...) {
  tibble::tibble(
    name = c("signed", "num_terms"),
    call_info = list(
      list(pkg = "dials", fun = "signed_hash"),
      list(pkg = "dials", fun = "num_hash")
    ),
    source = "recipe",
    component = "step_texthash",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_tf <- function(x, ...) {
  tibble::tibble(
    name = c("weight_scheme", "num_terms"),
    call_info = list(
      list(pkg = "dials", fun = "weight_scheme"),
      list(pkg = "dials", fun = "weight")
    ),
    source = "recipe",
    component = "step_tf",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_tokenfilter <- function(x, ...) {
  tibble::tibble(
    name = c("max_times", "min_times", "max_tokens"),
    call_info = list(
      list(pkg = "dials", fun = "max_times"),
      list(pkg = "dials", fun = "min_times"),
      list(pkg = "dials", fun = "max_tokens")
    ),
    source = "recipe",
    component = "step_tokenfilter",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.step_tokenize <- function(x, ...) {
  tibble::tibble(
    name = c("token"),
    call_info = list(
      list(pkg = "dials", fun = "token")
    ),
    source = "recipe",
    component = "step_tokenize",
    component_id = x$id
  )
}

#' @rdname tunable
#' @export
tunable.recipe <- function(x, ...) {
  if (length(x$steps) == 0) {
    res <- no_param
  } else {
    res <- purrr::map_dfr(x$steps, tunable)
    if (nrow(res) > 0) {
      res <- res[!is.na(res$name),]
    }
  }
  res
}


#' @importFrom utils globalVariables
utils::globalVariables(c("engine", "name", "func", "parsnip", "call_name"))
